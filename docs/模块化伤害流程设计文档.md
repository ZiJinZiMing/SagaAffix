# 模块化伤害流程设计文档

## 文档概述

本文档描述了基于DPU（DamageProcessUnit）的模块化伤害处理系统设计，该系统通过动态构建处理树的方式，解决复杂游戏中伤害计算的核心问题。

**版本**: 1.0  
**创建日期**: 2025-08-07  
**目标项目**: SagaStats插件词缀系统

## 系统概述

### 设计理念

模块化伤害流程将复杂的伤害计算分解为多个独立的处理单元（DPU），通过Type系统管理DPU之间的依赖关系和执行顺序，最终动态构建出适合当前上下文的伤害处理树。

### 核心架构

```
GE(GameplayEffect) → DPU Pool → Type系统排序 → 动态处理树 → 多目标输出
```

## 核心概念

### DPU（DamageProcessUnit）

**定义**: 伤害处理的最小功能单元，负责特定的计算或处理逻辑。

**特点**:
- 职责单一，功能明确
- 可独立开发和测试
- 支持热插拔和动态组合
- 通过组合而非继承实现功能复用

**基础接口**:
```cpp
class DPU {
public:
    virtual DamageData Process(DamageData input) = 0;
    virtual DPUTypeInfo GetTypeInfo() const = 0;
    virtual bool CanProcess(GameplayContext context) const = 0;
};
```

### DPU Pool（DPU池）

**定义**: 集中管理所有可用DPU的容器，支持多来源的DPU贡献。

**贡献者类型**:
- **玩家**: 装备词缀、技能、天赋相关DPU
- **怪物**: 种族特性、Boss机制相关DPU  
- **关卡**: 环境效果、地形影响相关DPU
- **攻击者**: 主动技能、攻击特效相关DPU
- **受击者**: 防御机制、被动效果相关DPU
- **世界**: 全局规则、系统机制相关DPU

**核心功能**:
```cpp
class DPUPool {
    vector<DPUContributor*> contributors;
    
    vector<DPU*> CollectRelevantDPUs(GameplayContext context);
    DamageProcessTree BuildProcessTree(vector<DPU*> dpus, GameplayEffect* ge);
};
```

### Type系统

**定义**: DPU的分类与依赖关系管理系统，确保在完全动态的前提下构建正确的执行顺序。

**核心功能**:
1. **依赖关系管理**: 定义DPU之间的输入输出依赖
2. **执行顺序控制**: 通过优先级和依赖解析确定执行序列
3. **类型分组**: 将功能相似的DPU归类管理
4. **冲突检测**: 识别和解决不兼容的DPU组合

**术语说明（requires/provides 属于 Type 系统）**:
- requires = `requiredInputTypes`：DPU 运行所需的输入类型集合，用于建立对上游产出的依赖。
- provides = `providedOutputTypes`：DPU 运行后可提供的输出类型集合，用于被下游消费。
- 二者共同决定依赖图（DAG）的边；结合 `priority`、`semanticTags`、`conflictsWith` 等进行拓扑排序、细粒度排序与冲突/语义校验。
- 注意：最终属性写入（如 Meter/Attribute 的应用）同样通过 DPU 表达，其 requires/provides 参与同一套依赖解算。

## Type系统设计方案

### 混合决策系统（推荐方案）

```cpp
struct DPUTypeInfo {
    int priority;                           // 基础优先级
    string processingStage;                 // 可选阶段语义标签（Soft Anchor，非强制，仅用于分组/可观测性/排序提示）
    vector<string> requiredInputTypes;      // 依赖的输入类型
    vector<string> providedOutputTypes;     // 提供的输出类型
    vector<string> semanticTags;            // 语义标签
    vector<string> conflictsWith;           // 冲突类型
};
```

### 决策算法

1. **（可选）阶段语义分组**: 若存在 processingStage，将其作为软锚点进行分组/日志分层；缺省则跳过。
2. **依赖排序**: 基于 requires/provides 构建依赖图并进行拓扑排序。
3. **优先级调整**: 在无直接依赖的同层节点内，使用 priority 做细粒度排序。
4. **语义验证**: 使用 semanticTags 进行合理性检查与规则校验。
5. **冲突解决**: 使用 conflictsWith 进行冲突检测，并按策略（如优先级胜、最近规则胜）解决或降级。

#### 设计原则：依赖图优先（Correctness First）
- 依赖图（requires/provides）是“正确性”的主轴，必须首先满足依赖关系的拓扑顺序与数据流转。
- `priority` 为可选，仅用于并列无依赖节点的稳定排序、冲突仲裁与调度提示；不得改变语义结果。
- 如存在语义上的先后关系，必须通过 requires/provides 建立真实依赖边，而非依赖 `priority` 人为排序。
- 若发现 `priority` 会影响最终结果，视为缺失真实依赖或聚合规则定义不全，应补齐依赖或完善聚合规则。

### 阶段语义标签（Soft Anchors，可选）

说明：阶段标签仅用于可读性与优化提示，不改变动态拓扑本质；即使不使用阶段标签，也可完全依赖 requires/provides 构建正确的执行图。以下枚举仅为常见标签示例：

```cpp
enum ProcessingStage {
    INPUT_VALIDATION = 100,    // 输入验证
    BASE_CALCULATION = 200,    // 基础计算  
    MODIFIER_APPLICATION = 300, // 修饰符应用
    RESISTANCE_CHECK = 400,    // 抗性检查
    CROSS_ATTRIBUTE = 500,     // 跨属性处理
    FINAL_OUTPUT = 600         // 最终输出
};
```

## 核心问题解决方案

本系统专门设计用于解决以下四个核心问题：

### 1. 多DPU来源 ✅

**问题**: DPU来自不同主体（玩家、怪物、关卡等），需要统一管理。

**解决方案**: 
- DPU Pool采用贡献者模式
- 各主体通过统一接口贡献DPU
- 支持动态添加和移除DPU贡献者

**实现示例**:
```cpp
// 各主体向Pool贡献DPU
player->ContributeDPUs(pool);      // 装备、技能DPU
monster->ContributeDPUs(pool);     // 种族、特性DPU  
level->ContributeDPUs(pool);       // 环境、规则DPU
```

### 2. 多属性处理 ✅

**问题**: 需要同时处理多种属性（HP、韧性、命中反应等）。

**解决方案**:
- DPU支持多属性输出
- 统一的数据结构承载多种属性变化
- Type系统确保属性间的正确处理顺序

**实现示例**:
```cpp
struct AttributeChanges {
    float hpDamage;
    float toughnessDamage;  
    float hitReactionDamage;
    map<string, float> customAttributes;
};

class MultiAttributeDPU : public DPU {
    AttributeChanges Process(DamageData input) override {
        // 同时计算多个属性的变化
        return CalculateAllAttributes(input);
    }
};
```

### 3. 级联属性影响 ✅

**问题**: 一个属性的修改会影响其他Meter或Attribute（如护盾-血量关系）。

**解决方案**:
- Type系统的依赖关系处理级联效应
- 中间结果存储支持跨DPU数据传递
- 条件执行机制支持动态处理逻辑

**实现示例**:
```cpp
// 护盾处理影响后续血量处理
ShieldProcessDPU -> HPProcessDPU -> MeterUpdateDPU

class ShieldDPU : public DPU {
    DamageData Process(DamageData input) override {
        if (hasShield) {
            // 护盾吸收部分伤害
            float absorbed = min(input.damage, currentShield);
            input.damage -= absorbed;
            input.shieldDamage = absorbed;
        }
        return input;
    }
};
```

### 4. 跨主体输出 ⚠️

**问题**: 伤害处理可能影响多个主体（如攻击者吸血、反伤等）。

**解决方案**:
- 扩展DPU输出模型支持多目标
- 输出分发层负责路由到正确目标
- 延迟应用机制确保事务一致性

**实现示例**:
```cpp
struct MultiTargetOutput {
    map<GameObject*, AttributeChanges> targetChanges;
};

class VampirismDPU : public DPU {
    MultiTargetOutput Process(DamageData input) override {
        MultiTargetOutput result;
        float healAmount = input.finalDamage * vampireRate;
        
        // 对受击者造成伤害
        result.targetChanges[input.defender].hpDamage = -input.finalDamage;
        // 对攻击者恢复生命
        result.targetChanges[input.attacker].hpHeal = +healAmount;
        
        return result;
    }
};
```

## 实现架构

### 核心类结构

```cpp
// 基础DPU接口
class DPU {
public:
    virtual DamageData Process(DamageData input) = 0;
    virtual DPUTypeInfo GetTypeInfo() const = 0;
    virtual bool CanProcess(GameplayContext context) const = 0;
};

// DPU贡献者接口
class DPUContributor {
public:
    virtual void ContributeDPUs(DPUPool& pool) = 0;
    virtual void RemoveDPUs(DPUPool& pool) = 0;
};

// DPU池管理器
class DPUPool {
private:
    vector<DPUContributor*> contributors;
    DPURegistry typeRegistry;
    
public:
    void RegisterContributor(DPUContributor* contributor);
    void UnregisterContributor(DPUContributor* contributor);
    
    vector<DPU*> CollectRelevantDPUs(GameplayContext context);
    DamageProcessTree BuildProcessTree(vector<DPU*> dpus);
};

// 类型注册表
class DPURegistry {
private:
    map<string, DPUTypeInfo> typeDefinitions;
    
public:
    void RegisterDPUType(string typeName, DPUTypeInfo info);
    vector<DPU*> ResolveExecutionOrder(vector<DPU*> dpus);
    bool ValidateDPUCombination(vector<DPU*> dpus);
};

// 伤害处理树
class DamageProcessTree {
private:
    vector<DPU*> orderedDPUs;
    
public:
    MultiTargetOutput Execute(GameplayEffect* ge, GameplayContext context);
    void Optimize(); // 性能优化
    string GetExecutionPlan(); // 调试信息
};
```

### 工作流程

1. **初始化阶段**
   - 各游戏对象注册为DPU贡献者
   - 建立Type系统的规则和优先级
   - 预加载常用的DPU组合

2. **伤害触发阶段**
   - GameplayEffect触发伤害事件
   - 收集上下文信息（施法者、目标、技能等）
   - 从DPU Pool筛选相关DPU

3. **树构建阶段**
   - Type系统解析DPU依赖关系
   - 排序并构建执行树
   - 验证组合的有效性

4. **执行阶段**
   - 按序执行DPU处理逻辑
   - 收集多目标输出结果
   - 应用最终的属性变化

5. **清理阶段**
   - 释放临时资源
   - 记录执行日志
   - 触发相关事件

## 优势特点

### 高度模块化
- 每个DPU职责单一，易于开发和维护
- 支持热插拔，便于动态扩展功能
- 通过组合实现复杂逻辑，避免继承层次复杂化

### 灵活组合
- 同一GE在不同上下文下构建不同处理树
- 支持复杂的词缀组合和相互作用
- 便于实现条件性效果和动态规则

### 性能优化
- 预计算常用DPU组合，减少运行时开销
- 并行执行独立的DPU，提高处理效率
- 延迟应用机制减少不必要的计算

### 调试友好
- 可视化执行树，便于理解处理流程
- 详细的执行日志，便于问题定位
- 单元测试友好，每个DPU可独立测试

## 扩展性考虑

### 新增词缀类型
1. 实现对应的DPU类
2. 注册Type信息到系统
3. 定义与现有DPU的关系

### 新增游戏机制
1. 创建新的ProcessingStage
2. 实现相关的DPU类型
3. 更新Type系统规则

### 性能优化方向
1. DPU组合的预计算和缓存
2. 执行树的编译优化
3. 并行处理的进一步优化

## 设计讨论与已识别问题（DAG / 附着 / Pool 闭包）

本节汇总近期讨论的关键结论与潜在风险，作为后续细化与验收的依据（中英术语对齐）。

### DAG 与 Tree 的关系
- **结论**：底层应以有向无环图（DAG）为准。仅当不存在汇合（fan-in）且各节点入度 ≤ 1 时，结构可退化为树/链。为可读性可提供树视图，但正确性以 DAG 为准。
- **原因**：存在并行分支与聚合（如 Crit/Additive 聚合、护盾吸收后与生命应用并行）即天然形成 DAG。

### 附着（anchorUnder）与显式依赖（tokens）
- **约定**：`anchorUnder: ParentDPU` 仅作为语法糖，编译期需转为显式依赖：父节点提供 `Token:Parent.Done`，子节点 `requires Token:Parent.Done`。
- **根聚合器等待**：根（如 `ApplyHealth`）应 `requires` 其实际需要的数据与叶子完成令牌（如 `DamageAfterShield`、`Token:ShieldApplied`）。
- **无护盾场景**：若上下文不满足（无护盾），不注入对应依赖；或使用条件 DPU 产出 `NoOpToken` 以满足聚合器等待的协议。

### Pool 选择与“带出父链”的闭包（closure expansion）
- **机制**：DPU 根据 GE/Context 从 `DPUPool` 被选出；若声明需要某根/父链，则由框架一并带入候选集。
- **风控**：
  - 循环检测：防止 A 带出 B、B 又带出 A。
  - 最大深度与已访问集：避免指数级扩张。
  - 缺父策略：缺少根时由框架提供聚合器单例（Aggregator Singleton），禁止叶子随意实例化根。

### 根节点唯一性与去重（Aggregator Singleton）
- **约束**：根类标记为单例聚合器，使用 `NodeId = (Type + 绑定键，如 Attacker/Defender/GEId)` 归一，多个叶子共享同一根实例。

### 依赖图是正确性的主轴（requires/provides first）
- **原则**：真实的先后关系必须通过 `requires/provides` 建立依赖；`priority` 仅用于并列无依赖节点的稳定排序/仲裁/调度提示，不能改变语义结果。
- **IO 校验**：附着后的最终图需做 IO 兼容校验（例如 `ApplyHealth` 依赖 `DamageAfterShield` 而非原始 `DamageAmount`）。

### 并行窗口与一次性提交（Commit/Dispatcher）
- **建议**：在 `ShieldAbsorb` 之后形成并行窗口：`ApplyShieldDelta` 与 `ApplyHealth` 并行产出变更；由提交器在末尾一次性落盘（事务性、幂等）。

### 冲突与互斥（Conflicts / Exclusive Capabilities）
- **需求**：多个来源可能声明互斥（如“替换基础伤害”）。
- **策略**：使用 `conflictsWith`/`exclusiveCapabilities` 标注冲突；仲裁策略可配（优先级胜/最近规则胜/显式权重），并输出可读诊断。

### 稳定排序与可重放（Determinism）
- **做法**：并列同层使用稳定排序键（如 `priority`、注册顺序或名称哈希），保证回放/日志/缓存稳定。不允许影响数值语义。

### 构建快照与缓存（Snapshot & Caching）
- **风险**：构图过程中 `DPUPool` 被修改导致非确定性。
- **建议**：按帧获取 Pool 快照；以 `GE + Context` 作为编排缓存键；支持命中率统计与失效策略。

### 诊断与可视化（Diagnostics & Visualization）
- **内容**：`GetExecutionPlan` 输出节点来源（自选/由谁带出）、附着父、注入的 token 依赖、冲突仲裁结论、并行分组与提交边界。

### 风险清单（待后续逐项对策）
- 隐式顺序：仅靠父子层级而未生成依赖边。
- 闭包膨胀：带出父链过深或循环。
- 多根竞争：未做聚合器单例归一。
- 虚假依赖：附着顺序与 IO 语义不匹配。
- 等待失配：根等待不存在的叶子。
- 并行丢失：被迫线性化导致性能退化。
- 非确定性：无稳定排序/无 Pool 快照。
- 可观测性不足：缺少构图/仲裁/并行边界的可视化。

## 执行模型与同步约束（Build-then-Run）

为避免执行期非确定性与隐式顺序，本系统采用“先构建、后执行、执行期冻结”的模型：

- **构建-执行分离**：先 BuildTree，再 ExecuteTree；执行过程中不改变图结构（不可变/冻结），所依赖的 `DPUPool` 使用构建时快照。
- **循环检测**：在 Build 阶段，统一对 IO 依赖与通过附着编译得到的 token 依赖做环检测；发现根-叶或任意环路，直接拒绝计划并输出诊断路径。
- **多树（Forest）支持**：当多个输入 GE 之间无依赖/无共享聚合器时，允许构建多棵独立的树（Forest）。提交器在末尾按事务语义合并各树的输出进行一次性应用。
- **DPU 运行时实例化（Instanced Nodes）**：执行时以实例节点参与运行，每个实例持有计算上下文（attacker/defender/GEId/随机源/帧戳等），实例的产出（含完成令牌）仅在本次执行内有效；类定义仅作为模板/工厂。
- **上下文传递**：实例上下文可沿依赖边向下游可见；聚合器（根）可访问其子链实例的必要上下文与产出，以完成汇合与提交。

## 可验收清单（Checklist）

- **架构骨干（DPU + Type System + Dynamic Process Tree）**
  - 通过标准：给定 GE + Context，可从 DPU Pool 构建无冲突的执行计划；同一 GE 在不同 Context 生成不同计划。
  - 验证方法：黑盒用例两组上下文对比执行计划与结果；检查计划中包含阶段/依赖/优先级的决策理由。

- **DPU 原子化与热插拔（Damage Process Unit）**
  - 通过标准：每个 DPU 职责单一；具备 `CanProcess(context)`；可在运行中增删且不影响其他 DPU。
  - 验证方法：单测覆盖输入/输出与边界；热插拔场景下执行计划稳定且错误隔离有日志。

- **多源贡献聚合（Multi-source Contributors）**
  - 通过标准：玩家/怪物/关卡/攻击者/受击者/世界可贡献/移除 DPU；生命周期与上下文一致。
  - 验证方法：逐类主体启停对执行计划的增量影响可追踪；移除后无残留效果。

- **Type 系统决策（Stages/Dependencies/Priority/Semantics/Conflicts）**
  - 通过标准：依赖图（requires/provides）为正确性主轴且拓扑排序正确；并列节点仅用 `priority` 做稳定排序/仲裁/调度提示，不改变语义；语义校验阻止不合理组合；冲突可检测并按策略解决（如优先级胜、最近规则胜），输出可读报告。
  - 验证方法：构造有环/缺依赖/冲突用例，期望为“报错或自动降级且有原因说明”。

- **阶段语义标签（Soft Anchors，Optional）**
  - 通过标准：是否使用阶段标签可配置；启用时仅用于日志分层/可视化/排序提示，不改变依赖解算；禁用时系统仍可通过 requires/provides 正确构图与执行。
  - 验证方法：同一用例在“开启/关闭阶段标签”两种模式下，执行结果一致；仅日志/可视化存在差异。

- **多属性处理（Multi-attribute Handling）**
  - 通过标准：一次处理可覆盖 HP/韧性/命中反应/自定义属性；属性聚合规则一致、可配置；新增自定义属性无需改框架。
  - 验证方法：多属性混合用例与只开单属性用例对比，一致性与可预测性达成。

- **级联影响（Cascading Effects）**
  - 通过标准：护盾→血量→Meter 等级联按依赖顺序生效；中间态可在 DPU 间传递；条件执行（如无护盾跳过）正确。
  - 验证方法：构造“有/无护盾”“过量伤害溢出”用例，对比中间态与最终值。

- **跨主体输出（Multi-target Output & Distribution）**
  - 通过标准：支持对受击者、攻击者及第三方目标的并行输出（如吸血/反伤/链接）；分发层一次性提交（事务性），幂等可重放。
  - 验证方法：断点失败/重试场景不产生双写或丢写；目标路由正确、顺序独立。

- **可观测性与调试（Observability）**
  - 通过标准：可导出执行计划（包含阶段、顺序、依赖/优先级理由）；每 DPU 结构化日志含耗时与 I/O 摘要；开关成本低。
  - 验证方法：在 Release 打开最小观测开销不超过既定阈值（例如 <1% 帧耗）。

- **性能目标（Performance & Caching & Parallelism）**
  - 通过标准：常用组合缓存命中率 ≥ 80%；首次树构建 < 2 ms（样机目标）；热路径执行 < 1 ms/GE（样机目标）；独立分支并行加速 ≥ 30%。
  - 验证方法：基准场景 1k 次执行采样；并行与串行对比；内存峰值与抖动在阈值内。

- **扩展性（Extensibility）**
  - 通过标准：新增词缀仅需“新增 DPU + 注册类型”，不改现有核心；新增阶段不需修改既有 DPU；变更可回退。
  - 验证方法：在空白分支新增一套 DPU 与阶段，核心模块零改动即可工作。

- **可靠性与事务一致性（Reliability & Transactions）**
  - 通过标准：延迟应用（apply-late）策略可整体提交/回滚；并发/重入安全；失败有分级降级与告警。
  - 验证方法：注入失败点（故障演练）验证回滚；并发触发无死锁与竞态。

- **冲突与隔离（Conflict Handling & Isolation）**
  - 通过标准：冲突检测可定位至 DPU 粒度；解决策略可配置；隔离保证单个异常不扩大影响面。
  - 验证方法：冲突矩阵覆盖高频组合；异常注入仅影响当前分支。

- **文档与样例（Docs & Samples）**
  - 通过标准：提供最小可运行样例 DPU（三件套：Shield / MultiAttribute / Vampirism）；操作指南与诊断手册覆盖“如何扩展/如何排错”。
  - 验证方法：新同学按文档 1 小时内完成新增 DPU 并通过单测。

- **一致性要求（Determinism，可选）**
  - 通过标准：同一输入下跨平台/回放一致；网络同步场景结果一致。
  - 验证方法：回放与实时对比哈希一致；跨平台差异在可控范围内或有规避策略。

## 总结

模块化伤害流程通过DPU + Type系统的设计，成功解决了复杂游戏中伤害处理的四个核心问题：多来源管理、多属性处理、级联影响和跨主体输出。该系统具有高度的模块化、灵活性和扩展性，为复杂的词缀系统提供了强有力的技术支撑。

---

*本文档将随着系统的发展持续更新和完善。*